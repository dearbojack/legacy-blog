<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source Sans Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="A translator you can trust.">
<meta name="keywords" content="翻译, translate, translation, translator">
<meta property="og:type" content="website">
<meta property="og:title" content="不止翻译">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="不止翻译">
<meta property="og:description" content="A translator you can trust.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="不止翻译">
<meta name="twitter:description" content="A translator you can trust.">

<link rel="canonical" href="http://yoursite.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>不止翻译</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="不止翻译" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不止翻译</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Maybe more.</p>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/24/fy007/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="PlayerUnknown">
      <meta itemprop="description" content="A translator you can trust.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不止翻译">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/24/fy007/" class="post-title-link" itemprop="url">为什么香港的年轻人如此愤怒</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-24 13:20:33" itemprop="dateCreated datePublished" datetime="2019-07-24T13:20:33+08:00">2019-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-07 15:45:08" itemprop="dateModified" datetime="2019-08-07T15:45:08+08:00">2019-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/07/24/fy007/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/07/24/fy007/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>原标题：缘何幻灭且愤怒的香港年轻人开始发出自己的声音 （<em>Why Hong Kong’s angry and disillusioned youth are making their voices heard</em>）<br>原作者：<a href="https://www.scmp.com/author/thomas-peter" target="_blank" rel="noopener">Thomas Peter</a><br>原文链接：<a href="https://www.scmp.com/magazines/post-magazine/long-reads/article/3019591/why-hong-kongs-angry-and-disillusioned-youth-are" target="_blank" rel="noopener">南华早报 </a><br> 翻译：PlayerUnknown</p>
</blockquote>
<hr>
<p>震动香港的 <a href="https://www.scmp.com/topics/hong-kong-extradition-law" target="_blank" rel="noopener">「反送中」</a> 游行中年轻人一直都站在最前线。这场骚乱的根源是人们害怕这会侵犯公民自由，也会让香港失去自治权，让一直拒绝让这个前英国殖民地全面实施民主制度的中央政府插手香港的治理。不过，在这个全世界人口最密集、生活成本极高的城市里，许多年轻人想拥有一个家的梦想 <a href="https://www.scmp.com/news/hong-kong/article/2046249/dream-owning-home-over-most-young-hong-kong-people" target="_blank" rel="noopener"> 永远无法实现 </a>，再加上<a href="https://www.scmp.com/business/money/wealth/article/3002347/hong-kong-shares-gold-worlds-most-expensive-city-alongside" target="_blank" rel="noopener"> 高昂的生活成本</a>，他们为此感到愤怒。</p>
<p>再过去的十年里，香港的住宅价格直线上涨了 242%，同时，香港已经连续第九年荣当全球房地产价格最昂贵的城市。</p>
<p>男性和女性的月平均工资分别为 19100 港币（16859 元）和 14700 港币（12975 元）。市中心只有一个卧室的公寓月平均租金为 16551 港币（14573 元）。根据 2018 年的年度国际人口住房购买力调查（Annual Demographia International Housing Affordability Survey），香港的平均房价是家庭年收入中位数的 20.9 倍。在香港买一个空中鞋盒一样的公寓的钱，你可以在法国买一座庄园。</p>
<p>数据如此，显然香港年轻人的怒起不会轻易消散。</p>
<p><img src="https://cdn.i-scmp.com/sites/default/files/d8/images/methode/2019/07/24/c35e7d34-ace4-11e9-a61f-bc570b50c4e7_1320x770_001846.JPG" alt></p>
<blockquote>
<p>冯成（音译）。图：Thomas Peter / 路透社</p>
</blockquote>
<p><strong>冯成（音译）</strong>，25 岁，平面设计师。他和自己的父母和兄弟住在坑口，图片中是他自己 54 平方英尺的卧室（约 5 平方米）。他认为是香港的制度剥夺了自己买到房子的机会，他说行政长官林郑月娥没有聆听人民的呼声。</p>
<p>「制度有问题……没有选票就可以组成政府，根本都不民主，」他说。</p>
<p><img src="https://cdn.i-scmp.com/sites/default/files/d8/images/methode/2019/07/24/c75f8a18-ace4-11e9-a61f-bc570b50c4e7_1320x770_001846.JPG" alt></p>
<blockquote>
<p>梁 Ruby。图：Thomas Peter / 路透社</p>
</blockquote>
<p><strong>梁 Ruby</strong>，22 岁，法学专业学生。他和自己的母亲和仆人住在九龙，图片中是她 75 平方英尺的卧室（约 7 平方米）。「他们说保持一国两制 50 年不改变，所以大家就担心 50 年后会怎样。会继续保持这样，还是香港被中国同化，像是深圳的一个区一样？这台可怕了，」梁说。</p>
<p>「大家喜欢可以全民普选，但事情并没有朝这个方向发展。我们不仅没有全民普选，中国政府在政治上的影响却越来越大。」</p>
<p><img src="https://cdn.i-scmp.com/sites/default/files/d8/images/methode/2019/07/24/c9892416-ace4-11e9-a61f-bc570b50c4e7_1320x770_001846.JPG" alt></p>
<blockquote>
<p>蔺 William。图：Thomas Peter / 路透社</p>
</blockquote>
<p><strong>蔺 William</strong>，22 岁，律师。他和父亲和兄弟住在沙田，图片中是他 70 平方英尺的房间（约 6.5 平方米）。「大家都想有房子。中国人的观念就是如此。那标志着你的人生到了一个新的阶段，成家了。我也想买个房子，但这个太难了，」蔺说。</p>
<p>「香港人除了中国人这个身份外，还应该有自己的身份。香港很特别。（游行的时候）我哭了很多次。看到发生的一切，看着自己的朋友被（橡皮子弹）打到，被催泪瓦斯呛到。」</p>
<p>「政府无动于衷，我感到很难过。他们好像根本不管年轻人怎么想，他们不关心。两万人上街游行，然后他们说，哦，我们听到你们说的了，不过我们还是要继续。」</p>
<p><img src="https://cdn.i-scmp.com/sites/default/files/d8/images/methode/2019/07/24/cc474a7a-ace4-11e9-a61f-bc570b50c4e7_1320x770_001846.JPG" alt></p>
<blockquote>
<p>韦 Eunice。</p>
</blockquote>
<p><strong>韦 Eunice</strong>，30 岁，小学教师。她和自己的父母和兄弟（见下面）住在 <a href="香港地名"> 太子 </a> 附近。图片中是她 80 平方英呎的卧室（约 7.5 平方米）。谈到为什么香港人觉得被中国政府遏制，韦说，「他们的管控越来越严，我们的自由越来越少。」</p>
<p>她还说，不过其他方面的问题也让人们的生活越来越难，特别是不公平的住房政策。这个政策下只会让富人越来越富。「我们香港的地方就这么点，人们买房子越来越难。房地产公司控制了所有的市场。」</p>
<p><img src="https://cdn.i-scmp.com/sites/default/files/d8/images/methode/2019/07/24/05c9f4aa-ace5-11e9-a61f-bc570b50c4e7_1320x770_001846.JPG" alt></p>
<blockquote>
<p>韦 John。</p>
</blockquote>
<p><strong>韦 John</strong>，26 岁，工程师。他和自己的父母以及姐姐 Eunice 住在太子附近，图片中是她 75 平方英尺的卧室。「让我愤怒的是政府允许大陆人购买我们非常稀缺的土地。房地产公司把房价抬得这么高，我们根本买不起，」韦说。</p>
<p>韦是一所香港名牌大学的毕业生。他已经工作两年了。两年来，他把工资存下来，一部分给到父母，一部分还自己的学生贷款，剩下的钱根本不够买个公寓。「我在考虑移民。去新加坡或者去泰国。因为我对香港的未来感到失望。我能预见到中国政府会继续剥夺我们的权利。」</p>
<p><img src="https://cdn.i-scmp.com/sites/default/files/d8/images/methode/2019/07/24/08ee621a-ace5-11e9-a61f-bc570b50c4e7_1320x770_001846.JPG" alt></p>
<blockquote>
<p>何 Zaleena。</p>
</blockquote>
<p><strong>何 Zaleena</strong>，22 岁，电影学院研究生。他和自己的父母住在美孚，图片中是她 75 平方英尺的卧室。「政治越来越糟糕。我们很多人都在尽力去保证我们已经赢得的东西不会被剥夺，我又一本美国护照，我可以离开。但是我希望我们可以改变些什么。如果情况变得特别糟糕，我会跑路的。但现在我们还在奋斗。」</p>
<p><img src="https://cdn.i-scmp.com/sites/default/files/d8/images/methode/2019/07/24/11cdc574-ace5-11e9-a61f-bc570b50c4e7_1320x770_001846.JPG" alt></p>
<blockquote>
<p>莫 Maisy。</p>
</blockquote>
<p><strong>莫 Maisy</strong>，22 岁，国际新闻学生。图片中是她 97 平方英呎的卧室，她和她的父亲住在火炭。父亲住在公寓的沙发上，因为地方太小，装不下第二张床了。她父母离婚了。「父亲住在沙发上我感到很难受，因为每个人都应该有自己的私人空间，」莫说。</p>
<p>「我们这一代人出生于 1997 年香港回归左右。我们知道我们是香港人。我门没有那种我们是中国人的感觉，直到中学才了解到。我们有自己的语言。对我们来说，这种转变很难，因为我们都觉得自己是香港人，我们很珍惜这个身份。我橛子我自己永远不会放弃言论自由。我认为香港的司法制度很不错。而且我喜欢讽刺时政。这些也是我选择新闻学和政治学的原因。」</p>
<p>「如果没有这些东西，即便大陆可以带来金钱或者利益，或者更大的房子，我也不会幸福。有时候你觉得自己被束缚住了。我们习惯了这种自由，所以可能不会太习惯（没有这种自由的生活）。」</p>
<p><img src="https://cdn.i-scmp.com/sites/default/files/d8/images/methode/2019/07/24/e6f34cc4-ace5-11e9-a61f-bc570b50c4e7_1320x770_001846.JPG" alt></p>
<blockquote>
<p>唐 Ruka。</p>
</blockquote>
<p><strong>唐 Ruka</strong>， 21 岁，学生。她和自己的两个妹妹一起住在一个 118 平方英尺的卧室。他们的父母也住在这个大窝口的公寓里。知道去年，他们一家五口一直住在一个 300 平方英尺的房子里。「我一直在努力工作赚钱好买个房子。我一周工作七天，有五份工作。一个办公室的工作，还有四个家教的工作。中间只有两三个小时的休息时间。我需要赚更多的钱，为了自己的学业，也为了我们家，」她说。</p>
<p>「生活在香港有太多压力了，物价的压力，上学的压力等等。我希望我们未来的一代不会和我们应一样要面对这些问题。」</p>
<p><img src="https://cdn.i-scmp.com/sites/default/files/d8/images/methode/2019/07/24/eb3a9eea-ace5-11e9-a61f-bc570b50c4e7_1320x770_001846.JPG" alt></p>
<blockquote>
<p>林 Roy。</p>
</blockquote>
<p><strong>林 Roy</strong>， 23 岁，人力资源职员。图片中是他 75 平方英尺的房间。他和他的母亲和四个妹妹住在油麻地。「我们宁愿站着输，也不愿作者坐着败，」他说。他认为年轻人已经下定决心为自己应得的东西站出来了，不过他也承认前路并不很明朗。「我们有时候也在想。要么放弃吧，我们搬到别的地方去算了。」</p>
<p><img src="https://cdn.i-scmp.com/sites/default/files/d8/images/methode/2019/07/24/45099496-ace9-11e9-a61f-bc570b50c4e7_1320x770_001846.JPG" alt></p>
<blockquote>
<p>李 Sonic。</p>
</blockquote>
<p>李 Sonic， 音乐人，作曲家，图片中是他 64 平方英呎的卧室。他和自己母亲一起住在钻石山的公寓。李说，「对我来说，雨伞革命就像是个故事，漫威的故事。但是在香港是不会有那样的结局的。世上没有超级英雄。任何事情都不是一次大运动就可以解决的吃。我已经不相信这些了。如果香港要改变的话，那也应该是小人物做些小事情，然后加在一起完成的。」</p>
<p>「是的，我担心（将来）有些书不能看，有些东西不能写，有些歌不能唱。不过这同时让艺术和音乐更加有力。特别是摇滚。如果我用音乐把现在发生的事情和我们要为之奋斗的东西唱出来，那这个城市的音乐一定会更加重要。」</p>
<p><img src="https://cdn.i-scmp.com/sites/default/files/d8/images/methode/2019/07/24/0bb70c66-a481-11e9-9a3c-98259c87fba2_1320x770_001846.JPG" alt></p>
<blockquote>
<p>何 Michael。</p>
</blockquote>
<p>何 Michael，24 岁，浸会大学政府和国际专业的研究生。Michael 何自己的父母住在杏花邨。他姐姐离家之后，他把两个房间的墙移除，所以他现在的房间有 118 平方公尺。他说游行是关于那些不公的情况，它们使得年轻人不能实现自己的梦想。「因为房价的问题，年轻人的成长，职业生涯的发展，毫无希望。」</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/04/fy000/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="PlayerUnknown">
      <meta itemprop="description" content="A translator you can trust.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不止翻译">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/04/fy000/" class="post-title-link" itemprop="url">试译：真实 Verity</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-04 15:28:24" itemprop="dateCreated datePublished" datetime="2019-06-04T15:28:24+08:00">2019-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-22 15:50:41" itemprop="dateModified" datetime="2019-08-22T15:50:41+08:00">2019-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/06/04/fy000/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/04/fy000/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>选自： 小说《Verity》，<a href="https://www.goodreads.com/book/show/41957126-verity" target="_blank" rel="noopener">Goodread 链接 </a>， <a href="https://www.amazon.com/Verity-Colleen-Hoover/dp/1791392792" target="_blank" rel="noopener"> 亚马逊链接 </a>。<br> 翻译： <a href="https://www.douban.com/people/2453069/" target="_blank" rel="noopener">PlayerUnknown</a></p>
<hr>
<p>鲜血飞溅过来之前，我已经听到了他头颅崩裂的声音。</p>
<p>我倒抽一口气，急忙后退一步，回到路边。一只鞋跟在路沿上卡了一下，我伸手紧紧抓住”禁止停车”标志的柱子好保持自己身体平衡。</p>
<p>那人几秒钟之前就站在我前面。我们一群人站在路边，等着人行横道的交通灯变绿。他提前走了下去，和一辆卡车撞到了一起。我冲过去想伸手拉住他，但伸出的手落了空，他还是走了下去。轮胎压过他头的时候，我闭上了眼睛。他头颅爆开的声音跟香槟酒瓶塞崩开的声音一模一样。</p>
<p>责任在他自己。他当时正心不在焉地盯着自己的手机——也许他每天都这样过马路，从没出过事故，习惯了吧。<strong>死于日常。</strong></p>
<p>周围的人也吓了一跳，不过并没有人尖叫。一个人从撞人的卡车上跳下来，立即跪在了那个男人的尸体边上。好几个人冲上去想帮忙，我向后退了几步。低头一看，我的白衬衫现在已经满是鲜血。<em>我不用看都知道，轮胎下的那个人没救了。他现在需要的不是救护车，而是灵车。</em></p>
<p>我有些喘不上气，转身想离开事故现场，但这时人行横道的绿灯亮了，乌泱泱的人群开始涌动起来。想在曼哈顿的人潮中逆流而上根本不可能。路过事故现场的时候，人群中的一些人甚至眼睛都没离开过自己的手机屏幕。我停了下来，等着人群变得稀薄。回头看了看事故现场，小心翼翼不去看那个男人的尸体。卡车司机现在站在卡车后面，圆睁着眼睛，正在打电话。三四个人在那里帮忙。还有几个人因着自己病态的好奇心，正拿手机拍着恐怖的事故现场。</p>
<p>如果我还住在弗吉尼亚的话，事情可能会以另一种方式展开。事故周围所有的人都会停下来。接着恐慌开始蔓延，人们开始尖叫，一群记者会在几分钟后出现在事故现场。但现在是在曼哈顿，卡车撞死行人的事故太稀松平常了，只能算个不大不小的麻烦事儿。对一些人来说可能只是交通延误了几分钟，对另一些人来说，可能也就跟衣柜坏了这个事差不多。这种事情太经常发生了，可能连报纸都根本不会报道。</p>
<blockquote>
<p>虽然这些人的冷漠让我有些不快，但我十年前搬到了这里，正是因为这个。像我这样的人属于这人烟浩穰的城市。在这里，我的人生怎样，根本无关紧要。这里比我有故事的人比比皆是，他们也远比我的更加让人同情 zh。在这里，我化于无形。无足轻重。曼哈顿的人太多了，它才没空在意我。而这，也正是我喜欢它的原因。</p>
</blockquote>
<p>“你没事吧？”</p>
<p>我抬起头，一个男的正抓着我的胳膊，扫视着我的衬衫。他上上下下地打量着我，评估着我的伤势，脸上写满了深深的担忧。从他的反应里我能看出来他不是那些久经磨练的老纽约客。他可能现在住在纽约，但无论他之前来自哪里，那里的环境都没有把他的同理心磨灭掉。</p>
<p>“你没有受伤吧？”那个陌生人又问了一遍，这一次他看着我的眼睛问的。</p>
<p>“没事。衣服上不是我的血。刚才我站在那人边上，然后他——“</p>
<p>我说不下去了。我刚刚看着一个人死了。我跟那个人挨得那么近，他的血溅到了我的身上。</p>
<blockquote>
<p>我来到这个城市，因为我想消失在人群中。但我并非铁石心肠。虽然那是我一直在努力的方向：像我脚下的混凝土一样坚硬、冷漠。不过那并非易事。我感觉到刚刚发生的事情正在我的心里慢慢平静下来。</p>
</blockquote>
<p>我伸出手捂住自己的嘴，但我又立刻把手拿开了，因为我感觉到嘴唇上有粘粘的东西。血。我低头看着自己的衬衫。那么多血，没有一滴是我的。我捏住衬衫，把它从胸膛上拉起来，但有些地方的血已经干了，和我的皮肤粘在了一起。</p>
<p>我想我需要一些水。我有点头晕，想摸摸自己的额头，揉揉自己的鼻子，但我不敢碰自己的脸。我抬起头，看着那个紧紧抓着我胳膊的男人。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/25/fy011/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="PlayerUnknown">
      <meta itemprop="description" content="A translator you can trust.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不止翻译">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/25/fy011/" class="post-title-link" itemprop="url">不要视图，只要控制器，成不？</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-06-25 12:05:50" itemprop="dateCreated datePublished" datetime="2018-06-25T12:05:50+08:00">2018-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-21 18:28:59" itemprop="dateModified" datetime="2019-08-21T18:28:59+08:00">2019-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/06/25/fy011/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/06/25/fy011/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文为 <a href="https://swift.gg/" target="_blank" rel="noopener">SwiftGG 项目组</a> 翻译文章，<a href="http://khanlou.com/2018/02/just-controllers/" target="_blank" rel="noopener">原文链接在此 </a>。<br> 原作者：Soroush Khanlou<br>原标题：Just Controllers<br>翻译：<em>PlayerUnkown</em><br>译文版权归译者所有，商业转载请联系 <a href="dearbojack.github.io"> 译者</a>。</p>
<hr>
<p>苹果官方文档中提到了 MVC 的软件设计模式。不过，苹果介绍的并不是本质意义上的 MVC 。<a href="http://khanlou.com/2014/03/model-view-whatever/" target="_blank" rel="noopener">关于这一点我之前也有写过一篇文章</a>，MVC 是为 Smalltalk 语言设计的一种设计模式。在 Smalltalk 语言里，MVC 的三个组件：模型（model）、视图（view）和控制器（controller）之间都可以相互通信。这就意味着或者视图知道如何实现一个模型，或者模型知道如何在视图中应用自己。</p>
<p>我们写 iOS 软件的时候，通常会把可以直接通信的视图和模型称之为“反模式”，不推荐这么做。我们所谓的 MVC 更准确的说其实是“模型 - 视图 - 适配器（Model - View - Adapter）”。我们说的“视图控制器”（适配器）其实只是模型和视图中间沟通的一个桥梁。笼统来讲，我觉得这是对正统 MVC 一个不错的改良——不是把视图和模型绑在一起，而是通过一个适配器把模型和视图联系起来，这个方法不错。然而，我不得不说，在我工作中涉及到的很多系统里，其实模型和视图都是分开的。</p>
<p>以上就是为什么 iOS 开发里会有视图控制器的原因：把模型和视图联系起来。但是这种模式的编码会产生一些问题：有一些代码看起来既不属于模型，也不属于视图，所以我们就把这些代码放到了视图控制器里，最后视图控制器变得超级臃肿。关于这个问题，我在博客里面讨论过 <a href="http://khanlou.com/2015/10/coordinators-redux/" target="_blank" rel="noopener"> 很多次</a>，但这次我想说的不是这个问题。</p>
<hr>
<p>我私下里听到过很多关于 <code>UIViewController</code> 的谈论。我认为 <code>UIViewController</code> 这个基本类写的不是很好，这个你用 UIKit 用得越久就越能感觉到。我听说 <code>UIViewController</code> 这个基本类型有 1 万到 2 万行代码（那是几年前了，现在可能已经超过两万行了）。</p>
<p>当我们需要把 <code>UIView</code> 和一个模型联系起来的时候，我们通常会把视图控制器分成一个个小的 视图控制器组件，然后再组装到一起。</p>
<p>但是，这样做太大动干戈（小题大做）了。一个小地方没处理好，就会出现很多 bug，而且这样的 bug 很难修复，也没有什么提示。然后，当你终于找到 bug 的时候，bug 通常是对 <code>didMove</code> 或者 <code>willMove</code> 调用的顺序不对，程序忽然就好了。其实，出现了 <code>didMove</code> 和<code>willMove</code>已经说明这些组件一些内部状态需要清理了。</p>
<p>这样的情况我自己就遇到过两次。第一次是我把视图控制器放在了 <code>tableView</code> 的<code>cell</code>里。出现的 bug 就是，table view 里面的一些内容总会莫名其妙地消失。然后过了好几个月，我才意识到我对 table view cells 的生命周期理解有误。</p>
<p>在我改正了一些对 <code>-addChildViewController</code> 的调用之后，程序就正常运行了。</p>
<p>这件事让我看到了一个很大的问题：视图控制器的视图并不是一个普普通通的视图。它知道自己不是一个普通的视图，而是一个视图控制器的视图，它有自己一些特性。</p>
<p>回过头去看，一切都很明显。<code>UIViewController</code>怎么知道什么时候该去调用 <code>viewDidLayoutSubviews</code>? 肯定是<code>view</code> 向它发送了请求，这就意味着视图对视图控制器是有一些了解的。</p>
<p>第二次是最近碰到的，这次我是在把一个视图控制器的视图作为一个 text field 的 <code>inputAccessoryView</code>。我是在实现一个通信软件（类似 iMessage）里<code>textField</code> 贴在屏幕底部的功能，整个过程十分挫败。我花了整整一天时间都没搞定，最后还是把这个视图转换成了一个普通的视图。</p>
<hr>
<p>所以，我们通常想让 <code>UIViewController1</code> 做的是哪些事情呢？</p>
<ul>
<li>承载视图</li>
<li>把模型和视图联系起来</li>
</ul>
<p>那 <code>UIViewController1</code> 还做了那些我们并不十分在意的事呢？</p>
<ul>
<li>为子视图控制器提供存储</li>
<li>把外观和过渡动画推送给子视图控制器</li>
<li>可以在类似 <code>UINavigationController</code> 的容器中显示</li>
<li>内存过低通知</li>
<li>处理状态栏</li>
<li>保存状态、恢复状态</li>
</ul>
<p>知道了这些，在一些特殊情况下，我们要做一个替代视图控制器的东西的时候，我们就知道了哪些东西是我们并不需要的。我喜欢这样，因为这样可以快速地解决问题，同时也符合我“自己的事情自己做”的性格。</p>
<p>还有一个问题，这个东西怎么命名呢？我觉得命名成一个视图控制器不太好，很容易被误解为一个 <code>UIViewController</code> 的子类。或者，我们就叫它 <code>Controller</code>? 我觉得可以（<a href="http://khanlou.com/2014/11/a-controller-by-any-other-name/" target="_blank" rel="noopener"> 尽管我之前可能有其他观点</a>），因为它的作用就是 iOS MVC 设计框架中控制器的作用（把视图和模型联系起来），但是还有其他一些备选：<code>Binder</code>（粘合）, <code>Binding</code>（捆绑）, <code>Pair</code>（配对）, <code>Mediator</code>（中介）, <code>Concierge</code>（前台）。</p>
<p>这个做法还有一个好处是，<strong>特别好写</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DestinationTextFieldController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> destination: <span class="type">Destination?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">DestinationTextFieldControllerDelegate?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> textField = <span class="type">UITextField</span>().configure(&#123;</span><br><span class="line">        $<span class="number">0</span>.autocorrectionType = .no</span><br><span class="line">        $<span class="number">0</span>.clearButtonMode = .always</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不用 <code>UIViewController</code> 的子类，写个这样的东西，可能会有人喊，“异教徒！烧死他！”但是，当 <code>UIViewController</code> 没有把自己该做的事情做好的时候，我们就应该抛弃它。</p>
<p>大家已将知道怎么给自己的新对象加新功能了。在我的这个例子中，控制器成了 <code>textField</code> 的代理，文字变化时发出事件（以及域元数据 domain metadta），同时提供更新视图（这个例子中是<code>textField</code>）的接口。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DestinationTextFieldController</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> isActive: <span class="type">Bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">self</span>.textField.isFirstResponder</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">(with destination: Destination)</span></span> &#123;</span><br><span class="line">		<span class="keyword">self</span>.destination = destination</span><br><span class="line">		configureView()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">configureView</span><span class="params">()</span></span> &#123;</span><br><span class="line">		textField.text = destination.descriptionForDisplay</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种新的控制器你还需要做其他几件事：</p>
<ul>
<li>你得新建一个实例变量来存储数据</li>
<li>你得负责一些触发事件——因为它不是一个视图控制器，没有<code>-viewDidAppear</code></li>
<li>你不是在 <code>UIKit</code> 框架里面了，所以其他一些 <code>UIKit</code> 的特性（<a href="https://developer.apple.com/documentation/uikit/uitraitcollection" target="_blank" rel="noopener">UITraitCollection</a>, <a href="https://developer.apple.com/documentation/uikit/uiview/positioning_content_relative_to_the_safe_area" target="_blank" rel="noopener">safe area insets</a>, 或者<a href="https://developer.apple.com/documentation/uikit/uiresponder" target="_blank" rel="noopener">UIResponder</a>）你都不能再使用了。如果要使用，你必须自己实现。</li>
</ul>
<p>使用这个对象不是很难，不过你还是需要写明它的数据存储方式， 防止它的内存被回收。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span>, <span class="title">DestinationTextFieldControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> destinationViewController = <span class="type">DestinationTextFieldController</span>()</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">		destinationViewController.delegate = <span class="keyword">self</span></span><br><span class="line">		view.addSubview(destinationViewController.view)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//handle any delegate methods</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>话说回来，即使你使用我说的这个方法，其他大部分的视图应该还会是视图控制器和 <code>UIViewController</code> 的子类。不过，在某些特殊的情况下，整合一个视图控制器会耗费你过多的精力，这时候采用这种方法，就可以避免再次被 <code>UIKit</code> 折磨。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/25/fy012/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="PlayerUnknown">
      <meta itemprop="description" content="A translator you can trust.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不止翻译">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/25/fy012/" class="post-title-link" itemprop="url">Swift 4 中的字符串</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-06-25 12:00:02" itemprop="dateCreated datePublished" datetime="2018-06-25T12:00:02+08:00">2018-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-21 18:32:26" itemprop="dateModified" datetime="2019-08-21T18:32:26+08:00">2019-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/06/25/fy012/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/06/25/fy012/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文为 <a href="https://swift.gg/" target="_blank" rel="noopener">SwiftGG 项目组</a> 翻译文章，<a href="https://oleb.net/blog/2017/11/swift-4-strings/" target="_blank" rel="noopener">原文链接在此 </a>。<br> 原作者：<a href="https://oleb.net/" target="_blank" rel="noopener">Ole Begemann</a><br>原标题： Strings in Swift 4<br>翻译：<em>PlayerUnkown</em><br>译文版权归译者所有，商业转载请联系 <a href="dearbojack.github.io"> 译者</a>。</p>
<hr>
<p>本系列其他文章：</p>
<ol>
<li><a href="https://oleb.net/blog/2014/07/swift-strings/" target="_blank" rel="noopener">Swift 1 中的字符串</a></li>
<li><a href="https://oleb.net/blog/2016/08/swift-3-strings/" target="_blank" rel="noopener">Swift 3 中的字符串</a></li>
<li>Swift 4 中的字符串（本文）</li>
</ol>
<p>本文节选自我们的新书《高级 Swift 编程》「字符串」这一章。《高级 Swift 编程》已根据 Swift 4 的新特性修订补充，新版现已上市。</p>
<hr>
<p>所有的现代编程语言都支持 Unicode 编码的字符串，但这通常只意味着它们的字符串可以存储 Unicode 编码的数据——并不意味着所有像获取字符串长度这样简单的操作都会得到「合情合理」的输出结果。</p>
<p>其实，大多数编程语言（以及这些语言中大部分字符串操作的代码）都在一定程度上对复杂的 Unicode 编码敬而远之。这会导致一些烦人的 bug。</p>
<p>Swift 对于字符串的实现为了支持 Unicode 做出了巨大的努力。Swift 中的 <a href="https://developer.apple.com/documentation/swift/string" target="_blank" rel="noopener"><code>String</code></a>（字符串）是一系列<a href="https://developer.apple.com/documentation/swift/character" target="_blank" rel="noopener"><code>Character</code></a> 值（字符）的集合。这里的 <code>Character</code> 指的就是人们看到的字母，无论这个字母是由多少个 Unicode 编码组成的。因此，所有对于 <code>Collection</code>（集合）的操作（比如<code>count</code> 或者<code>prefix(5)</code>）也同样是按照人们所理解的字母来操作的。</p>
<p>这样的设计在正确性上无可挑剔，但这是有代价的——人们对它不熟悉。如果你习惯了其他编程语言里字符串的整数索引，Swift 的设计会让你觉得笨重不堪。为什么 <code>str[999]</code> 不能获得字符串第一千个字符？为什么 <code>str[idx+1]</code> 不能获得下一个字符？为什么不能用类似 <code>&quot;a&quot;...&quot;z&quot;</code> 的方式遍历一个范围的<code>Character</code>（字符）？</p>
<p>同时，这样的设计对代码性能也有一定的影响：<code>String</code>不支持随意获取。换句话说，获得一个任意字符是无法简简单单用 O(1)的操作实现的——当字符宽度是个变量的时候，字符串只有查看过前面所有字符之后，才会知道第 n 个字符是什么。</p>
<p>在本章中，我们一起来详细讨论一下 Swift 中字符串的设计，以及一些获得功能和性能最优的技巧。不过，首先我们要先来学习一下 Unicode 编码的专业知识。</p>
<h2 id="Unicode：抛弃固定宽度"><a href="#Unicode：抛弃固定宽度" class="headerlink" title="Unicode：抛弃固定宽度"></a>Unicode：抛弃固定宽度 </h2><p> 本来事情很简单。<a href="https://en.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII 编码 </a> 的字符串用 0 到 127 之间的一系列整数表示。如果使用 8 比特的二进制数组合表示字符，甚至还多余一个比特！由于每个字符的长度固定，所以 ASCII 编码的字符串是可以随机获取的。</p>
<p>但是，如果不是英语而是其他国家的语言的话，其中的一些字符 ASCII 编码是不够的（其实即使是说英语的英国也有一个”£”符号）。这些语言中的特殊字符大多数都需要超过 7 比特的编码。在 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859" target="_blank" rel="noopener">ISO 8859</a> 标准中，就用多出来的那个比特定义了 16 种超出 ASCII 编码范围的编码，比如第一部分（ISO8859-1）包括了几种西欧语言的编码，第五部分包括了对西里尔字母语言的编码。</p>
<p>但这样的做法其实还有局限。如果你想根据 ISO8859 标准，用土耳其语写古希腊语的话，你就不走运了，因为你要么得选择第七部分（拉丁语 / 希腊语）或者第九部分（土耳其语）。而且，总的说，八个比特的空间无法编码很多种语言。例如，第六部分（拉丁语 / 阿拉伯语）就不包含同样使用阿拉伯字母的乌尔都语和波斯语中的很多字符。同时，越南语虽然使用的也是拉丁字母，但是有很多变音组合，这种情况只有替换掉一些原有 ASCII 编码的字母（<strong>from the lower half??</strong>）才可能存储到 8 个比特的空间里。而且，对其他很多东亚语言来说，这种方法根本无效。</p>
<p>一个固定宽度的编码空间不够的时候，你要做一个选择：要么提高存储空间，要么转换成宽度可变的编码。起先，<a href="https://en.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode</a>被定义为 2 字节固定宽度的格式，现在我们称之为<a href="https://en.wikipedia.org/wiki/Universal_Coded_Character_Set" target="_blank" rel="noopener">UCS-2</a>。彼时梦想尚未照进现实，后来人们发现，要实现大部分的功能，不仅 2 字节不够，甚至 4 个字节都远远不够。</p>
<p>所以到了今天，Unicode 编码的宽度是可变的，这种可变有两个不同的含义：一是说 Unicode scalars 可能由若干个代码块组成；一是说字符可能由若干个 scalars 组成。</p>
<p>Unicode 编码的数据可以用多种不同宽度的 <a href="https://www.unicode.org/glossary/#code_unit" target="_blank" rel="noopener"> 代码块（<em>code unit</em>）</a>来表示，最常见的是 8 比特（<a href="https://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">UTF-8</a>）和 16（<a href="https://en.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">UTF-16</a>）比特。UTF-8 编码的一大优势是它向后兼容 8 比特的 ACSCII 编码，这也是它取代 ASCII 成为互联网上最受欢迎的编码的一大原因。在 Swift 里面用 <code>UInt16</code> 和<code>UInt8</code>的数值代表 UTC-16 和 UTF-8 的代码块（别名分别是 <a href="https://developer.apple.com/documentation/swift/unicode.utf8/codeunit" target="_blank" rel="noopener"><code>Unicode.UTF16.CodeUnit</code></a> 和<a href="https://developer.apple.com/documentation/swift/unicode.utf16/codeunit" target="_blank" rel="noopener"><code>Unicode.UTF8.CodeUnit</code></a>）。</p>
<p>一个 <a href="https://www.unicode.org/glossary/#code_point" target="_blank" rel="noopener"><em> 代码点（code point）</em></a>指的是 Unicode 编码空间中一个单一的值，可能的范围是 <code>0</code> 到<code>0x10FFFF</code>(换算成十进制就是 1114111)。现在已使用的代码点只有大约 137000 个，所以还有很多空间可以存储各种 emoji。如果你使用的是 <a href="https://en.wikipedia.org/wiki/UTF-32" target="_blank" rel="noopener">UTF-32</a> 编码，那么一个代码点就是一个代码块；如果使用的是 UTF-8 编码，一个代码点可能有 1 到 4 个代码块组成。最初的 256 个 Unicode 编码的代码点对应着 Latin-1 中的字母。</p>
<p><a href="https://www.unicode.org/glossary/#unicode_scalar_value" target="_blank" rel="noopener">Unicode scalars</a>跟代码点基本一样，但是也有一点不一样。除开 <code>0xD800-0xDFFF</code> 中间的 2048 个代理代码点（<a href="https://en.wikipedia.org/wiki/UTF-16#U.2BD800_to_U.2BDFFF" target="_blank" rel="noopener"><em>surrogate code points</em></a>）之外，他们都是一样的。这 2048 个代理代码点是 UTF-16 中用作表示配对的前缀或尾缀编码。Scalars 在 Swift 中用 <code>\u{xxxx}</code> 表示，xxxx 代表十进制的数字。所以欧元符号在 Swift 里可以表示为 <code>&quot;€&quot;</code> 或<code>&quot;\u{20AC}&quot;</code>。与之对应的 Swift 类型是 <a href="https://developer.apple.com/documentation/swift/unicode.scalar" target="_blank" rel="noopener"><code>Unicode.Scalar</code></a>，一个<a href="https://developer.apple.com/documentation/swift/uint32" target="_blank" rel="noopener"><code>UInt32</code></a> 数值的封装。</p>
<p>为了用一个代码块代表一个 Unicode scalar，你需要一个 21 比特的编码机制（通常会达到 32 比特，比如 UTF-32），但是即便这样你也无法得到一个固定宽度的编码：最终表示字符的时候，Unicode 仍然是一个宽度可变的编码格式。屏幕上显示的一个字符，也就是用户通常认为的一个字符，可能需要多个 scalar 组合而成。Unicode 编码里把这种用户理解的字符称之为<a href="https://www.unicode.org/glossary/#extended_grapheme_cluster" target="_blank" rel="noopener">（扩展）字素集</a>(extended grapheme cluster)。</p>
<p>Scalar 组成字素集的规则决定了如何分词。例如，如果你按了一下键盘上的退格键，你觉得你的文本编辑器就应该删除掉一个字素集，即使那个“字符”是由多个 Unicode scalars 组成，且每个 scalar 在计算机内存上还由数量不等的代码块组成的。Swift 中用 <code>Character</code> 类型代表字素集。<code>Character</code>类型可以由任意数量的 Scalars 组成，只要它们形成一个用户看到的字符。在下一部分，我们会看到几个这样的例子。</p>
<h2 id="字素集和规范对等（Canonical-Equivalence）"><a href="# 字素集和规范对等（Canonical-Equivalence）" class="headerlink" title="字素集和规范对等（Canonical Equivalence）"></a>字素集和规范对等（Canonical Equivalence）</h2><h3 id="组合符号"><a href="# 组合符号" class="headerlink" title="组合符号"></a>组合符号 </h3><p> 这里有一个快速了解 <code>String</code> 类型如何处理 Unicode 编码数据的方法：写“é”的两种不同方法。Unicode 编码中定义为 <a href="https://codepoints.net/U+00E9" target="_blank" rel="noopener">U+00E9</a>， <em>Latin small letter e with acute（拉丁字母小写 e 加重音符号），</em> 单一值。但是你也可以写一个正常的 <a href="https://codepoints.net/U+0065" target="_blank" rel="noopener"> 小写 e</a>，再跟上一个 <a href="https://codepoints.net/U+0301" target="_blank" rel="noopener">U+0301</a>，<em>combining acute accent</em>（重音符号）。在这两种情况中，显示的都是é，用户当然会认为这两个“résumé”无论使用什么方式打出来的，肯定是相等的，长度也都是 6 个字符。这就是 Unicode 编码规范中所说的<a href="https://www.unicode.org/glossary/#canonical_equivalent" target="_blank" rel="noopener"> 规范对等（Canonically Equivalent）</a>。</p>
<p>而且，在 Swift 语言里，代码行为和用户预期是一致的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> single = <span class="string">"Pok\u&#123;00E9&#125;mon"</span></span><br><span class="line"><span class="keyword">let</span> double = <span class="string">"Poke\u&#123;0301&#125;mon"</span></span><br></pre></td></tr></table></figure>

<p>它们显示也是完全一致的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(single, double) <span class="comment">// → ("Pokémon", "Pokémon")</span></span><br></pre></td></tr></table></figure>

<p>它们的字符数也是一样的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">single.<span class="built_in">count</span> <span class="comment">// → 7</span></span><br><span class="line">double.<span class="built_in">count</span> <span class="comment">// → 7</span></span><br></pre></td></tr></table></figure>

<p>因此，比较起来，它们也是相等的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">single == double <span class="comment">// → true</span></span><br></pre></td></tr></table></figure>

<p>只有当你通过底层的显示方式查看的时候，才能看到它们的不同之处：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">single.utf16.<span class="built_in">count</span> <span class="comment">// → 7</span></span><br><span class="line">double.utf16.<span class="built_in">count</span> <span class="comment">// → 8</span></span><br></pre></td></tr></table></figure>

<p>这一点和 Foundation 中的 <a href="https://developer.apple.com/documentation/foundation/nsstring" target="_blank" rel="noopener"><code>NSString</code></a> 对比一下：在 <code>NSString</code> 中，两个字符串是不相等的，它们的<code>length</code>（很多程序员都用这个方法来确定字符串显示在屏幕上的长度）也是不同的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nssingle = single <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">nssingle.length <span class="comment">// → 7</span></span><br><span class="line"><span class="keyword">let</span> nsdouble = double <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">nsdouble.length <span class="comment">// → 8</span></span><br><span class="line">nssingle == nsdouble <span class="comment">// → false</span></span><br></pre></td></tr></table></figure>

<p>这里，<code>==</code>是定义为比较两个<code>NSObject</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension NSObject: Equatable &#123;</span><br><span class="line">    static func ==(lhs: NSObject, rhs: NSObject) -&gt; Bool &#123;</span><br><span class="line">        return lhs.isEqual(rhs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>NSString</code> 中，这个操作会比较两个 UTF-16 代码块。很多其他语言里面的字符串 API 也是这样的。如果你想做的是一个规范比较（cannonical comparison），你必须用<code>NSString.compare(_:)</code>。没听说过这个方法？将来遇到一些找不出来的 bug ，以及一些怒气冲冲的国外用户的时候，够你受的。</p>
<p>当然，只比较代码块有一个很大的优点是：速度快！在 Swift 里，你也可以通过 <code>utf16</code> 视图来实现这一点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">single.utf16.elementsEqual(double.utf16) <span class="comment">// → false</span></span><br></pre></td></tr></table></figure>

<p>为什么 Unicode 编码要支持同一字符的多种展现方式呢？</p>
<blockquote>
<p>因为 Latin-1 中已经有了类似é和ñ这样的字母，只有灵活的组合方式才能让长度可变的 Unicode 代码点兼容 Latin-1。</p>
<p>The existence of precomposed characters is what enables the opening range of Unicode code points to be compatible with Latin-1, which already had characters like é and ñ.</p>
</blockquote>
<p>虽然使用起来会有一些麻烦，但是它使得两种编码之间的转换变得简单快速。</p>
<p>而且抛弃变音形式也没有什么用，因为这种组合不仅仅只是两个两个的，有时候甚至是多种变音组合。例如，约鲁巴语中有一个字符是 ọ́ ，可以用三种不同方式写出来：一个 ó加一点，一个 ọ加一个重音，或者一个 o 加一个重音和一点。而且，对最后一种方式来说，两个变音的顺序无关紧要！所以，下面几种形式的写法都是相等的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> chars: [<span class="type">Character</span>] = [</span><br><span class="line">    <span class="string">"\u&#123;1ECD&#125;\u&#123;300&#125;"</span>,      <span class="comment">// ọ́</span></span><br><span class="line">    <span class="string">"\u&#123;F2&#125;\u&#123;323&#125;"</span>,        <span class="comment">// ọ́</span></span><br><span class="line">    <span class="string">"\u&#123;6F&#125;\u&#123;323&#125;\u&#123;300&#125;"</span>, <span class="comment">// ọ́</span></span><br><span class="line">    <span class="string">"\u&#123;6F&#125;\u&#123;300&#125;\u&#123;323&#125;"</span>  <span class="comment">// ọ́</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> allEqual = chars.<span class="built_in">dropFirst</span>()</span><br><span class="line">    .all(matching: &#123; $<span class="number">0</span> == chars.first &#125;) <span class="comment">// → true</span></span><br></pre></td></tr></table></figure>

<p><code>all(matching:)</code>方法用来检测条件是否对所有序列中的元素都为真：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">all</span><span class="params">(matching predicate: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">try</span> !predicate(element) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，一些变音元素可以加无穷个。这一点，<a href="http://knowyourmeme.com/memes/zalgo" target="_blank" rel="noopener">网上流传很广 </a> 的一个颜文字表现得很好：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zalgo = <span class="string">"s̼̐͗͜o̠̦̤ͯͥ̒ͫ́ͅo̺̪͖̗̽ͩ̃͟ͅn̢͔͖͇͇͉̫̰ͪ͑"</span></span><br><span class="line"></span><br><span class="line">zalgo.<span class="built_in">count</span> <span class="comment">// → 4</span></span><br><span class="line">zalgo.utf16.<span class="built_in">count</span> <span class="comment">// → 36</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>zalgo.count</code>返回值是 4（正确的），而 <code>zalgo.utf16.count</code> 返回值是 36。如果你的代码连网上的颜文字都无法正确处理，要它何用？？</p>
<p>Unicode 编码的字素分割规则甚至在你处理纯 ASCII 编码的字符的时候也有影响，回车 <a href="https://codepoints.net/U+000D" target="_blank" rel="noopener">CR</a> 和换行 <a href="https://codepoints.net/U+000A" target="_blank" rel="noopener">LF</a> 这一个字符对在 Windows 系统上通常表示新开一行，但它们其实只是一个字素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CR+LF is a single Character</span></span><br><span class="line"><span class="keyword">let</span> crlf = <span class="string">"\r\n"</span></span><br><span class="line">crlf.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure>

<h3 id="Emoji"><a href="#Emoji" class="headerlink" title="Emoji"></a>Emoji</h3><p>许多其他编程语言处理包含 emoji 的字符串的时候会让人意外。许多 emoji 的 Unicode scalar 无法存储在一个 UTF-16 的代码块里面。有些语言（例如 Java 或者 C#）把字符串当做 UTF-16 代码块的集合，这些语言定义 <a href="https://emojipedia.org/face-with-tears-of-joy/" target="_blank" rel="noopener">“😂”</a> 为两个“字符”的长度。Swift 也是这么处理的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oneEmoji = <span class="string">"😂"</span> <span class="comment">// U+1F602</span></span><br><span class="line">oneEmoji.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，重要的是字符串是如何展现给程序的，<strong>不是 </strong> 字符串在内存中是如何存储的。对于非 ASCII 的字符串，Swift 内部用的是 UTF-16 的编码，这只是内部的实现细节。公共 API 还是基于字素集（grapheme cluster）的。</p>
</blockquote>
<p>有些 emoji 由多个 scalars 组成。emoji 中的国旗是由两个对应 ISO 国家代码的 <a href="https://en.wikipedia.org/wiki/Regional_Indicator_Symbol" target="_blank" rel="noopener"> 地区标识符号（reginal indicator symbols）</a>组成的。Swift 里将一个国旗视为一个<code>Character</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flags = <span class="string">"🇧🇷🇳🇿"</span></span><br><span class="line">flags.<span class="built_in">count</span> <span class="comment">// → 2</span></span><br></pre></td></tr></table></figure>

<p>要检查一个字符串由几个 Unicode scalars 组成，需要使用 <a href="https://developer.apple.com/documentation/swift/string/1539070-unicodescalars" target="_blank" rel="noopener"><code>unicodeScalars</code></a> 视图。这里，我们将 scalar 的值格式化为十进制的数字，这是代码点的普遍格式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flags.unicodeScalars.<span class="built_in">map</span> &#123;</span><br><span class="line">    <span class="string">"U+\(String($0.value, radix: 16, uppercase: true))"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// → ["U+1F1E7", "U+1F1F7", "U+1F1F3", "U+1F1FF"]</span></span><br></pre></td></tr></table></figure>

<p>肤色是由一个基础的角色符号（ 例如👧）加上一个肤色修饰符（例如🏽）组成的，Swift 里是这么处理的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> skinTone = <span class="string">"👧🏽"</span> <span class="comment">// 👧 + 🏽</span></span><br><span class="line">skinTone.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure>

<p>这次我们用 Foundation API 里面的 <a href="https://oleb.net/blog/2016/01/icu-text-transforms/" target="_blank" rel="noopener">ICU string transform</a> 把 Unicode scalars 转换成官方的 Unicode 名称：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">StringTransform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> toUnicodeName = <span class="type">StringTransform</span>(rawValue: <span class="string">"Any-Name"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Unicode</span>.<span class="title">Scalar</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// The scalar’s Unicode name, e.g. "LATIN CAPITAL LETTER A".</span></span><br><span class="line">    <span class="keyword">var</span> unicodeName: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="comment">// Force-unwrapping is safe because this transform always succeeds</span></span><br><span class="line">        <span class="keyword">let</span> name = <span class="type">String</span>(<span class="keyword">self</span>).applyingTransform(.toUnicodeName,</span><br><span class="line">            <span class="built_in">reverse</span>: <span class="literal">false</span>)!</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The string transform returns the name wrapped in "\\N&#123;...&#125;". Remove those.</span></span><br><span class="line">        <span class="keyword">let</span> prefixPattern = <span class="string">"\\N&#123;"</span></span><br><span class="line">        <span class="keyword">let</span> suffixPattern = <span class="string">"&#125;"</span></span><br><span class="line">        <span class="keyword">let</span> prefixLength = name.hasPrefix(prefixPattern) ? prefixPattern.<span class="built_in">count</span> : <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> suffixLength = name.hasSuffix(suffixPattern) ? suffixPattern.<span class="built_in">count</span> : <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(name.<span class="built_in">dropFirst</span>(prefixLength).<span class="built_in">dropLast</span>(suffixLength))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skinTone.unicodeScalars.<span class="built_in">map</span> &#123; $<span class="number">0</span>.unicodeName &#125;</span><br><span class="line"><span class="comment">// → ["GIRL", "EMOJI MODIFIER FITZPATRICK TYPE-4"]</span></span><br></pre></td></tr></table></figure>

<p>这段代码里面最重要的是对 <code>applyingTransform(.toUnicodeName,...)</code> 的调用。其他的代码只是把转换方法返回的名字清理了一下，移除了括号。这段代码很保守：先是检查了字符串是否符合期望的格式，然后计算了从头到尾的字符数。如果将来转换方法返回的名字格式发生了变化，最好输出原字符串，而不是移除多余字符后的字符串。</p>
<p>注意我们是如何使用标准的集合（<code>Collection</code>）方法 <code>dropFirst</code> 和<code>droplast</code>进行移除操作的。如果你想对字符串进行操作，但是又不想对字符串进行手动索引，这就是一个很好的例子。这个方法同样也很高效，因为 <code>dropFisrt</code> 和<code>dropLast</code>方法返回的是 <code>Substring</code> 值，它们只是原字符串的一部分。在我们最后一步创建一个新的 <code>String</code> 字符串，赋值为这个 substring 之前，它是不占用新的内存的。关于这一点，我们在这一章的后面还有很多东西会涉及到。</p>
<p>Emoji 里面对家庭和夫妻的表示（例如<a href="https://emojipedia.org/family-man-woman-girl-boy/" target="_blank" rel="noopener">👨‍👩‍👧‍👦</a> 和 <a href="https://emojipedia.org/couple-with-heart-woman-woman/" target="_blank" rel="noopener">👩‍❤️‍👩</a> ）是 Unicode 编码标准面临的又一个挑战。由于性别以及人数的可能组合太多，为每种可能的组合都做一个代码点肯定会有问题。再加上每个人物角色的肤色的问题，这样做几乎不可行。Unicode 编码是这样解决这个问题的，它将这种 emoji 定义为一系列由零宽度连接符（<a href="https://codepoints.net/U+200D" target="_blank" rel="noopener"><em>zero-width joiner</em></a>）联系起来的 emoji 。这样下来，这个家庭👨‍👩‍👧‍👦 emoji 其实就是 <a href="https://emojipedia.org/man/" target="_blank" rel="noopener"><em>man</em> 👨</a> + ZWJ + <a href="https://emojipedia.org/woman/" target="_blank" rel="noopener"><em>woman</em> 👩</a> + ZWJ + <a href="https://emojipedia.org/girl/" target="_blank" rel="noopener"><em>girl</em>👧</a> + ZWJ + <a href="https://emojipedia.org/boy/" target="_blank" rel="noopener"><em>boy</em> 👦</a>。而零宽度连接符的作用就是让操作系统知道这个 emoji 应该只是一个字素。</p>
<p>我们可以验证一下到底是不是这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> family1 = <span class="string">"👨‍👩‍👧‍👦"</span></span><br><span class="line"><span class="keyword">let</span> family2 = <span class="string">"👨\u&#123;200D&#125;👩\u&#123;200D&#125;👧\u&#123;200D&#125;👦"</span></span><br><span class="line">family1 == family2 <span class="comment">// → true</span></span><br></pre></td></tr></table></figure>

<p>在 Swift 里，这样一个 emoji 也同样被认为是一个字符<code>Character</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">family1.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br><span class="line">family2.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure>

<p>2016 年新引入的职业类型 emoji 也是这种情况。例如女性消防队员<a href="https://emojipedia.org/female-firefighter/" target="_blank" rel="noopener">👩‍🚒</a> 就是 <a href="https://emojipedia.org/woman/" target="_blank" rel="noopener"><em>woman</em> 👩</a> + ZWJ + <a href="https://emojipedia.org/fire-engine/" target="_blank" rel="noopener"><em>fire engine</em> 🚒</a>。男性医生就是<a href="https://emojipedia.org/man/" target="_blank" rel="noopener"><em>man</em> 👨</a> + ZWJ + <a href="https://emojipedia.org/staff-of-aesculapius/" target="_blank" rel="noopener"><em>staff of aesculapius</em> ⚕</a>（译者注：阿斯克勒庇厄斯，是古希腊神话中的医神，一条蛇绕着一个柱子指医疗相关职业）。</p>
<p>将这些一系列零宽度连接符连接起来的 emoji 渲染为一个字素是操作系统的工作。2017 年，Apple 的操作系统表示支持 Unicode 编码标准下的 RGI 系列（“<a href="https://unicode.org/emoji/charts/emoji-zwj-sequences.html" target="_blank" rel="noopener">recommended for general interchange</a>”）。如果没有字素可以正确表示这个序列，那文本渲染系统会回退，显示为每个单个的字素。</p>
<p>注意这里又可能会导致一个理解偏差，即用户所认为的字符和 Swift 所认为的字素集之间的偏差。我们上面所有的例子都是担心编程语言会把字符 <strong> 数多了</strong>，但这里正好相反。举例来说，上面那个家庭的 emoji 里面涉及到的肤色 emoji 还未被收录到 RGI 集合里面。但尽管大多数操作系统都把这系列 emoji 渲染成多个字素，但 Swift 仍旧只把它们看做一个字符，因为 Unicode 编码的分词规则和渲染无关：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Family with skin tones is rendered as multiple glyphs</span></span><br><span class="line"><span class="comment">// on most platforms in 2017</span></span><br><span class="line"><span class="keyword">let</span> family3 = <span class="string">"👱🏾\u&#123;200D&#125;👩🏽\u&#123;200D&#125;👧🏿\u&#123;200D&#125;👦🏻"</span> <span class="comment">// → "👱🏾‍👩🏽‍👧🏿‍👦🏻"</span></span><br><span class="line"><span class="comment">// But Swift still counts it as a single Character</span></span><br><span class="line">family3.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.emojipedia.org/diverse-emoji-families-come-to-windows/" target="_blank" rel="noopener">Windows 系统已经可以 </a> 把这些 emoji 渲染为一个字素了，其他操作系统厂家肯定也会尽快支持。但是，有一点是不变的：无论一个字符串的 API 如何精心设计，都无法完美支持每一个细小的案例，因为文本太复杂了。</p>
<blockquote>
<p>过去 Swift 很难跟得上 Unicode 编码标准改变的步伐。Swift 3 渲染肤色和零宽度连接符系列 emoji 是错误的，因为当时的分词算法是根据上一个版本的 Unicode 编码标准。自 Swift 4 起，Swift 开始启用操作系统的 <a href="http://site.icu-project.org" target="_blank" rel="noopener">ICU</a>库。因此，只要用户更新他们的操作系统，你的程序就会采用最新的 Unicode 编码标准。硬币的另一面是，你开发中看到的和用户看到的东西可能是不一样的。</p>
</blockquote>
<p>编程语言如果不全盘考虑 Unicode 编码的复杂性的话，在处理文本的时候会出现很多问题。上面的这么多例子我们只是在谈其中的一个问题：字符串的长度。如果一个编程语言不是按字素集处理字符串，而这个字符串又包含很多字符序列的话，这时候一个简简单单的反序输出字符串的操作会变得多么复杂。</p>
<p>这不是个新问题，但是 emoji 的流行使得糟糕的文本处理方法造成的问题更容易浮出表面，即使你的用户群大部分是说英语的。而且，错误的级别也大大提升：十年前，弄错一个变音符号的字母可能只会造成 1 个字符数的误差，现在如果弄错了 emoji 的话很可能就是 10 个字符数的误差。例如，一个四人家庭的 emoji 在 UTF-16 编码下是 11 个字符，在 UTF-8 编码下就是 25 个字符了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">family1.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br><span class="line">family1.utf16.<span class="built_in">count</span> <span class="comment">// → 11</span></span><br><span class="line">family1.utf8.<span class="built_in">count</span> <span class="comment">// → 25</span></span><br></pre></td></tr></table></figure>

<p>也不是说其他编程语言就完全没有符合 Unicode 编码标准的 API，大部分还是有的。例如，<code>NSString</code>就有一个 <a href="https://developer.apple.com/documentation/foundation/nsstring/1416774-enumeratesubstrings" target="_blank" rel="noopener"><code>enumerateSubstrings</code></a> 的方法可以按照字素集遍历一个字符串。但是缺省设置很重要，而 Swift 的原则就是缺省情况下，就按正确的方式来做。而且如果你需要低一个抽象级别去看，<code>String</code>也提供不同的视图，然你可以直接从 Unicode scalar 或者代码块的级别操作。下面的内容里我们还会涉及到这一点。</p>
<h2 id="字符串和集合"><a href="# 字符串和集合" class="headerlink" title="字符串和集合"></a>字符串和集合 </h2><p> 我们已经看到，<code>String</code>是一个 <code>Character</code> 值的集合。在 Swift 语言发展的前三年里，<code>String</code>这个类在遵守还是不遵守 <code>Collection</code> 集合协议这个问题上左右摇摆了几次。坚持不要遵守集合协议的人认为，如果遵守的话，程序员会认为所有通用的集合处理算法用在字符串上是绝对安全的，也绝对符合 Unicode 编码标准的，但是显然有一些特例存在。</p>
<p>举一个简单的例子，两个集合相加，得到的新的集合的长度肯定是两个子集合长度的和。但是在字符串中，如果第一个字符串的后缀和第二个字符串的前缀形成了一个字素集，长度就会有变化了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flagLetterJ = <span class="string">"🇯"</span></span><br><span class="line"><span class="keyword">let</span> flagLetterP = <span class="string">"🇵"</span></span><br><span class="line"><span class="keyword">let</span> flag = flagLetterJ + flagLetterP <span class="comment">// → "🇯🇵"</span></span><br><span class="line">flag.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br><span class="line">flag.<span class="built_in">count</span> == flagLetterJ.<span class="built_in">count</span> + flagLetterP.<span class="built_in">count</span> <span class="comment">// → false</span></span><br></pre></td></tr></table></figure>

<p>出于这种考虑，在 Swift 2 和 Swift 3 中，<code>String</code>并没有被算作一个集合。这个特性是作为 <code>String</code> 的一个 <a href="https://developer.apple.com/documentation/swift/string/1540072-characters" target="_blank" rel="noopener"><code>characters</code></a> 视图存在的，和其他几个集合视图一样：<a href="https://developer.apple.com/documentation/swift/string/1539070-unicodescalars" target="_blank" rel="noopener"><code>unicodeScalars</code></a>，<a href="https://developer.apple.com/documentation/swift/string/1539703-utf8" target="_blank" rel="noopener"><code>utf8</code></a> 和<a href="https://developer.apple.com/documentation/swift/string/1541301-utf16" target="_blank" rel="noopener"><code>utf16</code></a>。选择一个特定的视图，就相当于让程序员转换到另一种“处理集合”的模式，相应的，程序员就必须考虑到这种模式下可能产生的问题。</p>
<p>但是，在实际应用中，这个改变提升了学习成本，降低了可用性；单单为了保证在那些极端个例中的正确性（其实在真实应用中很少遇到，除非你写的是个文本编辑器的应用）做出这样的改变太不值得了。因此，在 Swift 4 中，<code>String</code>再次成了一个集合。<code>characters</code>视图还在，但是只是为了向后兼容 Swift 3。</p>
<h3 id="双向获取，而非任意获取"><a href="# 双向获取，而非任意获取" class="headerlink" title="双向获取，而非任意获取"></a>双向获取，而非任意获取 </h3><p> 然而，<code>String</code>并 <strong> 不是 </strong> 一个可以任意获取的集合，原因的话，上一部分的几个例子已经展现的很清楚。一个字符到底是第几个字符取决于它前面有多少个 Unicode scalar，这样的情况下，根本不可能实现任意获取。由于这个原因，Swift 里面的字符串遵守双向获取（<a href="https://developer.apple.com/documentation/swift/bidirectionalcollection" target="_blank" rel="noopener"><code>BidirectionalCollection</code></a>）规则。可以从字符串的两头数，代码会根据相邻字符的组成，跳过正确数量的字节。但是，每次访问只能上移或者下移一个字符。</p>
<p>在写处理字符串的代码的时候，要考虑到这种方式的操作对代码性能的影响。那些依靠任意获取来保证代码性能的算法对 Unicode 编码的字符串并不合适。我们看一个例子，我们要获取一个字符串所有 prefix 的列表。我们只需要得到一个从零到字符串长度的一系列整数，然后根据每个长度的整数在字符串中找到对应长度的 prefix ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> allPrefixes1: [<span class="type">Substring</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>...<span class="keyword">self</span>.<span class="built_in">count</span>).<span class="built_in">map</span>(<span class="keyword">self</span>.<span class="keyword">prefix</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = <span class="string">"Hello"</span></span><br><span class="line">hello.allPrefixes1 <span class="comment">// → ["","H","He","Hel","Hell","Hello"]</span></span><br></pre></td></tr></table></figure>

<p>尽管这段代码看起来很简单，但是运行性能很低。它先是遍历了字符串一次，计算出字符串的长度，这还 OK。但是每次对 <a href="https://developer.apple.com/documentation/swift/substring/2893985-prefix" target="_blank" rel="noopener"><code>prefix</code></a> 进行 n+1 的调用都是一次 <em>O(n)* 操作，因为<code>prefix</code> 方法需要从字符串的开头往后找出所需数量的字符。而在一个线性运算里进行另一个线性运算就意味着算法已经成了 *O(n2)</em> ——随着字符串长度的增加，算法所需的时间是呈指数级增长的。</p>
<p>如果可能的话，一个高性能的算法应该是遍历字符串一次，然后通过对字符串索引的操作得到想要的子字符串。下面是相同算法的另一个版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> allPrefixes2: [<span class="type">Substring</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">""</span>] + <span class="keyword">self</span>.<span class="built_in">indices</span>.<span class="built_in">map</span> &#123; index <span class="keyword">in</span> <span class="keyword">self</span>[...index] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello.allPrefixes2 <span class="comment">// → ["", "H", "He", "Hel", "Hell", "Hello"]</span></span><br></pre></td></tr></table></figure>

<p>这段代码只需要遍历字符串一次，得到字符串的索引（<a href="https://developer.apple.com/documentation/swift/bidirectionalcollection/1785188-indices" target="_blank" rel="noopener"><code>indices</code></a>）集合。一旦完成之后，之后再 <code>map</code> 内的操作就只是<em>O(1)</em>。整个算法也只是 <em>O(n)</em>。</p>
<h3 id="范围可替换，不可变"><a href="# 范围可替换，不可变" class="headerlink" title="范围可替换，不可变"></a>范围可替换，不可变 </h3><p><code>String</code> 还遵从于 <a href="https://developer.apple.com/documentation/swift/rangereplaceablecollection" target="_blank" rel="noopener"><code>RangeReplaceableCollection</code></a>（范围可替换）的集合操作。也就是说，你可以先按字符串索引的形式定义出一个范围，然后通过调用<a href="https://developer.apple.com/documentation/swift/string/1641462-replacesubrange" target="_blank" rel="noopener"><code>replaceSubrange</code></a>（替换子范围）方法，替换掉字符串中的一些字符。这里有一个例子。替换的字符串可以有不同的长度，甚至还可以是空的（这时候就相当于调用<a href="https://developer.apple.com/documentation/swift/string/2893740-removesubrange" target="_blank" rel="noopener"><code>removeSubrange</code></a> 方法了）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hello, world!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> comma = greeting.index(of: <span class="string">","</span>) &#123;</span><br><span class="line">    greeting[..&lt;comma] <span class="comment">// → "Hello"</span></span><br><span class="line">    greeting.replaceSubrange(comma..., with: <span class="string">"again."</span>)</span><br><span class="line">&#125;</span><br><span class="line">greeting <span class="comment">// → "Hello again."</span></span><br></pre></td></tr></table></figure>

<p>同样，这里也要注意一个问题，如果替换的字符串和原字符串中相邻的字符形成了新的字素集，那结果可能就会有点出人意料了。</p>
<p>字符串无法提供的一个类集合的特性是：<a href="https://developer.apple.com/documentation/swift/mutablecollection" target="_blank" rel="noopener"><code>MutableCollection</code></a>。该协议给集合除 <code>get</code> 之外，添加了一个通过下标进行单一元素 <code>set</code> 的特性。这并不是说字符串是不可变的——我们上面已经看到了，有好几种变化的方法。你无法完成的是使用下标操作符替换其中的一个字符。许多人直觉认为用下标操作符替换一个字符是即时发生的，就像数组 <a href="https://developer.apple.com/documentation/swift/array" target="_blank" rel="noopener"><code>Array</code></a>里面的替换一样。但是，因为字符串里的字符长度是不定的，所以替换一个字符的时间和字符串的长度呈线性关系：替换一个元素的宽度会把其他所有元素在内存中的位置重新洗牌。而且，替换元素索引后面的元素索引在洗牌之后都变了，这也是跟人们的直觉相违背的。出于这些原因，你必须使用 <code>replaceSubrange</code> 进行替换，即使你变化只是一个元素。</p>
<h2 id="字符串索引"><a href="# 字符串索引" class="headerlink" title="字符串索引"></a>字符串索引 </h2><p> 大多数编程语言都是用整数作为字符串的下标，例如 <code>str[5]</code> 就会返回 <code>str</code> 的第六个”字符“（无论这个语言定义的“字符”是什么）。Swift 却不允许这样。为什么呢？原因可能你已经听了很多遍了：下标应该是使用固定时间的(无论是直觉上，还是根据集合协议)，但是查询第 n 个“字符”的操作必须查询它前面所有的字节。</p>
<p><a href="https://developer.apple.com/documentation/swift/string.index" target="_blank" rel="noopener">字符串索引（<code>String.Index</code>）</a>是字符串及其视图使用的索引类型。它是个不透明值（opaque value，内部使用的值，开发者一般不直接使用），本质上存储的是从字符串开头算起的字节偏移量。如果你想计算第 n 个字符的索引，它还是一个 <em>O(n)</em> 的操作，而且你还是必须从字符串的开头开始算起，但是一旦你有了一个正确的索引之后，对这个字符串进行下标操作就只需要<em>O(1)</em> 次了。关键是，找到现有索引后面的元素的索引的操作也会变得很快，因为你只需要从已有索引字节后面开始算起了——没有必要从字符串开头开始了。这也是为什么有序（向前或是向后）访问字符串里的字符效率很高的原因。</p>
<p>字符串索引操作的依据跟你在其他集合里使用的所有 API 一样。因为我们最常用的集合——数组——使用的是整数索引，我们通常使用简单的算术来操作，所以有一点很容易忘记： <a href="https://developer.apple.com/documentation/swift/string/1782583-index" target="_blank" rel="noopener"><code>index(after:)</code></a> 方法返回的是下一个字符的索引：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"abcdef"</span></span><br><span class="line"><span class="keyword">let</span> second = s.index(after: s.startIndex)</span><br><span class="line">s[second] <span class="comment">// → "b"</span></span><br></pre></td></tr></table></figure>

<p>使用 <a href="https://developer.apple.com/documentation/swift/string/1786175-index" target="_blank" rel="noopener"><code>index(_:offsetBy:)</code></a>方法，你可以通过一次操作，自动地访问多个字符，</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Advance 4 more characters</span></span><br><span class="line"><span class="keyword">let</span> sixth = s.index(second, offsetBy: <span class="number">4</span>)</span><br><span class="line">s[sixth] <span class="comment">// → "f"</span></span><br></pre></td></tr></table></figure>

<p>如果可能超出字符串末尾，你可以加一个 <a href="https://developer.apple.com/documentation/swift/anybidirectionalcollection/1781464-index" target="_blank" rel="noopener"><code>limitedBy:</code></a> 参数。如果在访问到目标索引之前到达了字符串的末尾，这个方法会返回一个 <code>nil</code> 值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> safeIdx = s.index(s.startIndex, offsetBy: <span class="number">400</span>, limitedBy: s.endIndex)</span><br><span class="line">safeIdx <span class="comment">// → nil</span></span><br></pre></td></tr></table></figure>

<p>比起简单的整数索引，这无疑使用了更多的代码。<strong>这是 Swift 故意的。</strong>如果 Swift 允许对字符串进行整数索引，那不小心写出性能烂到爆的代码（比如在一个循环中使用整数的下标操作）的诱惑太大了。</p>
<p>然而，对一个习惯于处理固定宽度字符的人来说，刚开始使用 Swift 处理字符串会有些挑战——没有了整数索引怎么搞？而且确实，一些看起来简单的任务处理起来还得大动干戈，比如提取字符串的前四个字符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[..&lt;s.index(s.startIndex, offsetBy: <span class="number">4</span>)] <span class="comment">// → "abcd"</span></span><br></pre></td></tr></table></figure>

<p>不过谢天谢地，你可以使用集合的接口来获取字符串，这意味着许多适用于数组的方法同样也适用于字符串。比如上面那个例子，如果使用 <code>prefix</code> 方法就简单得多了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="keyword">prefix</span>(<span class="number">4</span>) <span class="comment">// → "abcd"</span></span><br></pre></td></tr></table></figure>

<p>（注意，上面的几个方法返回的都是子字符串 <a href="https://developer.apple.com/documentation/swift/substring" target="_blank" rel="noopener"><code>Substring</code></a>，你可以使用一个 <code>String.init</code> 把它转换为字符串。关于这一部分，我们下一部分会讲更多。）</p>
<p>没有整数索引，循环访问字符串里的字符也很简单，用 <code>for</code> 循环。如果你想按顺序排列，使用 <a href="https://developer.apple.com/documentation/swift/sequence/1641222-enumerated" target="_blank" rel="noopener"><code>enumerated()</code></a>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i, <span class="built_in">c</span>) <span class="keyword">in</span> s.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(i): \(c)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者如果你想找到一个特定的字符，你可以使用 <a href="https://developer.apple.com/documentation/swift/string/2893264-index" target="_blank" rel="noopener"><code>index(of:)</code></a>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">"Hello!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> idx = hello.index(of: <span class="string">"!"</span>) &#123;</span><br><span class="line">    hello.insert(contentsOf: <span class="string">", world"</span>, at: idx)</span><br><span class="line">&#125;</span><br><span class="line">hello <span class="comment">// → "Hello, world!"</span></span><br></pre></td></tr></table></figure>

<p> <a href="https://developer.apple.com/documentation/swift/string/2893571-insert" target="_blank" rel="noopener"><code>insert(contentsOf:at:)</code></a> 方法可以在指定索引前插入相同类型的另一个集合（比如说字符串里的字符）。并不一定是另一个字符串，你可以很容易地把一个字符的数组插入到一个字符串里。</p>
<h2 id="子字符串"><a href="# 子字符串" class="headerlink" title="子字符串"></a>子字符串 </h2><p> 和其他的集合一样，字符串有一个特定的切片类型或者说子序列类型（ <a href="https://developer.apple.com/documentation/swift/collection/1641276-subsequence" target="_blank" rel="noopener"><code>SubSequence</code></a> ）：子字符串（ <a href="https://developer.apple.com/documentation/swift/substring" target="_blank" rel="noopener"><code>Substring</code></a>）。子字符串就像是一个数组切片（ <a href="https://developer.apple.com/documentation/swift/arrayslice" target="_blank" rel="noopener"><code>ArraySlice</code></a>）：它是原字符串的一个视图，起始索引和结束索引不同。子字符串共享原字符串的文本存储空间。这是一个很大的优势，对一个字符串进行切片操作不占用内存空间。在下面的例子中，创建 <code>firstWord</code> 变量不占用内存：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence = <span class="string">"The quick brown fox jumped over the lazy dog."</span></span><br><span class="line"><span class="keyword">let</span> firstSpace = sentence.index(of: <span class="string">""</span>) ?? sentence.endIndex</span><br><span class="line"><span class="keyword">let</span> firstWord = sentence[..&lt;firstSpace] <span class="comment">// →"The"</span></span><br><span class="line">type(of: firstWord) <span class="comment">// → Substring.Type</span></span><br></pre></td></tr></table></figure>

<p>切片操作不占用内存意义重大，特别是在一个循环中，比如你要通过循环访问整个字符串（可能会很长）来提取其中的字符。比如在文本中找到一个单词使用的次数，比如解析一个 CSV 文件。这里有一个非常有用的字符串处理操作：split。<code>split</code>是 <code>Collection</code> 集合中定义的一个方法，它会返回一个子序列的数组（即<code>[Substring]</code>）。它最常见的变种就像是这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(separator: Element, maxSplits: Int = Int.<span class="built_in">max</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        omittingEmptySubsequences: Bool = <span class="literal">true</span>)</span></span> -&gt; [<span class="type">SubSequence</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以这样使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> poem = <span class="string">"""</span></span><br><span class="line"><span class="string">    Over the wintry</span></span><br><span class="line"><span class="string">    forest, winds howl in rage</span></span><br><span class="line"><span class="string">    with no leaves to blow.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">let</span> lines = poem.<span class="built_in">split</span>(separator: <span class="string">"\n"</span>)</span><br><span class="line"><span class="comment">// → ["Over the wintry", "forest, winds howl in rage", "with no leaves to blow."]</span></span><br><span class="line">type(of: lines) <span class="comment">// → Array&lt;Substring&gt;.Type</span></span><br></pre></td></tr></table></figure>

<p>这个跟 <code>String</code> 继承自 <code>NSString</code> 的 <a href="https://developer.apple.com/documentation/swift/stringprotocol/2923413-components" target="_blank" rel="noopener"><code>components(separatedBy:)</code></a> 方法的功能类似，你还可以用一些额外设置比如是否抛弃空的组件。而且在这个操作中，所有输入字符串都没有创建新的复制。因为还有其他 <code>split</code> 方法的变种可以完成操作，除了比较字符以外，<code>split</code>还可以完成更多的事情。下面这个例子是文本换行算法的一个原始的实现，最后的代码计算了行的长度：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">wrapped</span><span class="params">(after: Int = <span class="number">70</span>)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> lines = <span class="keyword">self</span>.<span class="built_in">split</span>(omittingEmptySubsequences: <span class="literal">false</span>) &#123;</span><br><span class="line">            character <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">switch</span> character &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"\n"</span>, <span class="string">""</span> <span class="keyword">where</span> i &gt;= after:</span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lines.joined(separator: <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sentence.wrapped(after: <span class="number">15</span>)</span><br><span class="line"><span class="comment">// →"The quick brown\nfox jumped over\nthe lazy dog."</span></span><br></pre></td></tr></table></figure>

<p>或者，考虑写另外一个版本，可以拿到一个包含多个分隔符的序列：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">split</span>&lt;S: Sequence&gt;<span class="params">(separators: S)</span></span> -&gt; [<span class="type">SubSequence</span>]</span><br><span class="line">        <span class="keyword">where</span> <span class="type">Element</span> == <span class="type">S</span>.<span class="type">Element</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">split</span> &#123; separators.<span class="built_in">contains</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，你还可以这么写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello, world!"</span>.<span class="built_in">split</span>(separators: <span class="string">",!"</span>) <span class="comment">// → ["Hello", "world"]</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串协议 -StringProtocol"><a href="# 字符串协议 -StringProtocol" class="headerlink" title="字符串协议 StringProtocol"></a>字符串协议 <code>StringProtocol</code></h3><p><code>Substring</code>和 <code>String</code> 几乎有着相同的接口，因为两种类型都遵守一个共同的字符串协议（<a href="https://developer.apple.com/documentation/swift/stringprotocol" target="_blank" rel="noopener"><code>StringProtocol</code></a>）。因为几乎所有的字符串 API 都是在 <a href="https://developer.apple.com/documentation/swift/stringprotocol" target="_blank" rel="noopener"><code>StringProtocol</code></a> 中定义的，所以操作<code>Substring</code> 跟操作 <code>String</code> 没有什么大的区别。但是，在有些情况下，你还必须把子字符串转换为字符串的类型；就像所有的切片（slice）一样，子字符串只是为了短时间内的存储，为了防止一次操作定义太多个复制。如果操作结束之后，你还想保留结果，将数据传到另一个子系统里，你应该创建一个新的字符串。你可以用一个 <code>Substring</code> 的值初始化一个<code>String</code>，就像我们在这个例子中做的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastWord</span><span class="params">(<span class="keyword">in</span> input: String)</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">    <span class="comment">// Process the input, working on substrings</span></span><br><span class="line">    <span class="keyword">let</span> words = input.<span class="built_in">split</span>(separators: [<span class="string">","</span>, <span class="string">""</span>])</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> lastWord = words.last <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="comment">// Convert to String for return</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(lastWord)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lastWord(<span class="keyword">in</span>: <span class="string">"one, two, three, four, five"</span>) <span class="comment">// →"five"</span></span><br></pre></td></tr></table></figure>

<p>不建议子字符串长期存储背后的原因是子字符串一直关联着原字符串。即使一个超长字符串的子字符串只有一个字符，只要子字符串还在使用，那原先的字符串就还会在内存里，即使原字符串的生命周期已经结束。因此，长期存储子字符串可能导致内存泄漏，因为有时候原字符串已经无法访问了，但是还在占用内存。</p>
<p>操作过程中使用子字符串，操作结束的时候才创建新的字符串，通过这种方式，我们把占用内存的动作推迟到了最后一刻，而且保证了我们只会创建必要的字符串。在上面的例子当中，我们把整个字符串（可能会很长）分成了一个个的子字符串，但是在最后只是创建了一个很短的字符串。（例子中的算法可能效率不是那么高，暂时忽略一下；从后先前找到第一个分隔符可能是个更好的方法。）</p>
<p>遇到只接受 <code>Substring</code> 类型的方法，但是你想传递一个 <code>String</code> 的类型，这种情况很少见（大部分的方法都接受 <code>String</code> 类型或者接受所有符合字符串协议的类型），但是如果你确实需要传递一个 <code>String</code> 的类型，最便捷的方法是使用范围操作符（range operator）<code>...</code>，不限定范围：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子字符串和原字符串的起始和结束的索引完全一致 </span></span><br><span class="line"><span class="keyword">let</span> substring = sentence[...]</span><br></pre></td></tr></table></figure>

<hr>
<p><code>Substring</code>类型是 Swift 4 中的新特性。在 Swift 3 中，<code>String.CharacterView</code>是自己独有的切片类型（slice type）。这么做的优势是用户只需要了解一种类型，但这也意味这如果存储一个子字符串，整个原字符串也会占据内存，即使它正常情况下应该已经被释放了。Swift 4 损失了一点便捷，换来的是的方便的切片操作和可预测的内存使用。</p>
<p>要求 <code>Substring</code> 到<code>String</code>的转换必须明确写出，Swift 团队认为这没那么烦人。如果实际应用中大家都觉得问题很大，他们也会考虑直接在编译器中写一个 <code>Substring</code> 和<code>String</code>之间的 <a href="https://github.com/apple/swift/blob/master/docs/StringManifesto.md#substrings" target="_blank" rel="noopener"> 模糊子类型关系（implicit subtype relationship）</a>，就像 <code>Int</code> 是<code>Optional&lt;Int&gt;</code>的子类型一样。这样你就可以随意传递 <code>Substring</code> 类型，编译器会帮你完成类型转换。</p>
<hr>
<p>你可能会倾向于充分利用字符串协议，把你所有的 API 写成接受所有遵守字符串协议的实例，而不是仅仅接受 <code>String</code> 字符串。但 Swift 团队的建议是，<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170626/037828.html" target="_blank" rel="noopener">别这样</a>：</p>
<blockquote>
<p>总的来说，我们建议继续使用字符串变量。 使用字符串变量，大多数的 API 都会比把它们写成通用类型（这个操作本身就有一些代价）更加简洁清晰，用户在必要的时候进行一些转换并不需要花费很大的精力。</p>
</blockquote>
<p>一些 API 极有可能和子字符串一起使用，同时无法泛化到适用于整个序列 <code>Sequence</code> 或集合 <code>Collection</code> 的级别，这些 API 可以不受这条规则的限制。一个例子就是标准库中的 <a href="https://developer.apple.com/documentation/swift/sequence/1641243-joined" target="_blank" rel="noopener"><code>joined</code></a> 方法。Swift 4 中，针对遵守字符串协议的元素组成的序列（<code>Sequence</code>）添加了一个重载（overload）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">StringProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 两个元素中间加上一个特定分隔符后</span></span><br><span class="line">    <span class="comment">/// 合并序列中所有元素，返回一个新的字符串</span></span><br><span class="line">    <span class="comment">/// Returns a new string by concatenating the elements of the sequence,</span></span><br><span class="line">    <span class="comment">/// adding the given separator between each element.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">joined</span><span class="params">(separator: String = <span class="string">""</span>)</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，你就可以直接对一个子字符串的数组调用 <code>joined</code> 方法了，没必要遍历一次数组并且把每个子字符串转换为新的字符串。这样，一切都很方便快速。</p>
<p>数值类型初始器（number type initializer）可以将字符串转换为一个数字。在 Swift 4 中，它也接受遵守字符串协议的值。如果你要处理一个子字符串的数组的话，这个方法很顺手：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> commaSeparatedNumbers = <span class="string">"1,2,3,4,5"</span></span><br><span class="line"><span class="keyword">let</span> numbers = commaSeparatedNumbers</span><br><span class="line">    .<span class="built_in">split</span>(separator: <span class="string">","</span>).flatMap &#123; <span class="type">Int</span>($<span class="number">0</span>) &#125;</span><br><span class="line"><span class="comment">// → [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>由于子字符串的生命周期很短，所以不建议方法的返回值是子字符串，除非是序列 <code>Sequence</code> 或集合 <code>Collection</code> 的一些返回切片的 API。如果你写了一个类似的方法，只对字符串有意义，那让它的返回值是子字符串，好让读者明白这个方法并不会产生复制，不会占用内存。创建新字符串的方法需要占用内存，比如 <a href="https://developer.apple.com/documentation/swift/stringprotocol/2908613-uppercased" target="_blank" rel="noopener"><code>uppercased()</code></a>，这类的方法应该返回 <code>String</code> 字符串类型的值。</p>
<p>如果你想为字符串类型扩展新的功能， 好的办法是将扩展放在字符串协议 <code>StringProtocol</code> 上，保证 API 在字符串和子字符串层面的一致性。字符权协议的设计初衷就是替换原先在字符串基础上做的扩展功能。如果你想把现有的扩展从字符串转移到字符串协议上，你要做的唯一改变就是，把传递 <code>Self</code> 给只接受具体 <code>String</code> 值的 API 替换为<code>String(Self)</code>。</p>
<p>需要记住的一点是，从 Swift 4 开始，如果你有一些自定义的字符串类型，不建议遵守字符串协议<code>StringProtocol</code>。官方文档明确警告：</p>
<blockquote>
<p>不要做任何新的遵守字符串协议 <code>StringProtocol</code> 的声明。只有标准库里的 <code>String</code> 和<code>Substring</code>是有效的遵守类型。</p>
</blockquote>
<p>允许开发者写自己的字符串类型（比如有特殊的存储优化或性能优化）是终极目标，但是现阶段协议的设计还没有最终确定，所以现在就启用它可能会导致你的代码在 Swift 5 里无法正常运行。</p>
<p><em>… <snip>  &lt; 内容有删减 &gt;…</snip></em></p>
<h2 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结 </h2><p>Swift 语言里的字符串跟其他所有的主流编程语言里的字符串差异很大。当你习惯于把字符串当做代码块的数组后，你得花点时间转化思维，习惯 Swift 的处理方法：它把遵守 Unicode 编码标准放在<strong> 简洁 </strong> 前面。</p>
<p>总的来讲，我们认为 Swift 的选择是正确的。Unicode 编码文本比其他编程语言所认为的要复杂得多。长远来看，处理你可能写出来的 bug 的时间肯定比学习新的索引方式（忘记整数索引）所需的时间多。</p>
<p>我们已经习惯于任意获取“字符”，以至于我们都忘了其实这个特性在真正的字符串处理的代码里很少用到。我们希望通过这一章里的例子可以说服大家，对于大多数常规的操作，简单的按序遍历也完全 OK。强迫你清楚地写出你想在哪个层面（字素集，Unicode scalar，UTF-16 代码块，UTF-8 代码块）处理字符串是另一项安全措施；读你代码的人会对你心存感激的。</p>
<p>2016 年 7 月，Chris Lattner 谈到了 <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html" target="_blank" rel="noopener">Swift 语言字符串处理的目标</a>，他最后是这么说的：</p>
<blockquote>
<p>我们的目标是在字符串处理上超越 Perl。</p>
</blockquote>
<p>当然 Swift 4 还没有实现这个目标——很多想要的特性还没实现，包括把 Foundation 库中的诸多字符串 API 转移到标准库，正则表达式的自然语言支持，字符串格式化和解析 API，更强大的字符串插入功能。好消息是 Swift 团队已经表示 <a href="https://github.com/apple/swift/blob/master/docs/StringManifesto.md" target="_blank" rel="noopener">会在将来解决所有这些问题</a>。</p>
<hr>
<p>如果喜欢本文的话，请考虑 <a href="https://gumroad.com/a/507458675" target="_blank" rel="noopener"> 购买全书</a>。谢谢！</p>
<p>全书中第一张是本文的两本。讨论了其他的一些问题，包括如何使用以及什么时候使用字符串的代码块视图，如何和 Foundation 里的处理字符串的 API（例如 <a href="https://developer.apple.com/documentation/foundation/nsregularexpression" target="_blank" rel="noopener"><code>NSRegularExpression</code></a>或者 <a href="https://developer.apple.com/documentation/foundation/nsattributedstring" target="_blank" rel="noopener"><code>NSAttributedString</code></a>） 配合处理。贴别是后面这个问题很难，而且很容易犯错。除此之外还讨论了其他标准库里面机遇字符串的 API，例如文本输出流（<a href="https://developer.apple.com/documentation/swift/textoutputstream" target="_blank" rel="noopener"><code>TextOutputStream</code></a>）或自定义字符串转换（<a href="https://developer.apple.com/documentation/swift/customstringconvertible" target="_blank" rel="noopener"> <code>CustomStringConvertible</code></a>）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="PlayerUnknown"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">PlayerUnknown</p>
  <div class="site-description" itemprop="description">A translator you can trust.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:ross4han@gmail.com" title="E-Mail → mailto:ross4han@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/p/1005052736192503" title="Weibo → https://weibo.com/p/1005052736192503" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PlayerUnknown</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://maxxd.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
